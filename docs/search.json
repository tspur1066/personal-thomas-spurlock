[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Thomas’ Cool Little Website",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Thomas Spurlock is a fella who thinks Medievals are really neat."
  },
  {
    "objectID": "about.html#basic-info",
    "href": "about.html#basic-info",
    "title": "About",
    "section": "",
    "text": "Thomas Spurlock is a fella who thinks Medievals are really neat."
  },
  {
    "objectID": "about.html#aeneid-1.1",
    "href": "about.html#aeneid-1.1",
    "title": "About",
    "section": "Aeneid 1.1",
    "text": "Aeneid 1.1\nArma virumque cano"
  },
  {
    "objectID": "about.html#virgils-aeneid-1.1",
    "href": "about.html#virgils-aeneid-1.1",
    "title": "About",
    "section": "Virgil’s Aeneid 1.1",
    "text": "Virgil’s Aeneid 1.1\nArma virumque cano"
  },
  {
    "objectID": "about.html#caesars-de-bello-gallico-1.1",
    "href": "about.html#caesars-de-bello-gallico-1.1",
    "title": "About",
    "section": "Caesar’s De Bello Gallico 1.1",
    "text": "Caesar’s De Bello Gallico 1.1\nGallia est omnis divisa in partes tres, quarum unam incolunt Belgae, aliam Aquitani, tertiam qui ipsorum lingua Celtae, nostra Galli appellantur.\n“All Gaul is divided into three parts, of which the Belgae inhabit one, another the Aquitani, the third those who in the language of themselves are called the Celts, in ours the Gauls.”"
  },
  {
    "objectID": "about.html#the-song-of-roland-1.1-3",
    "href": "about.html#the-song-of-roland-1.1-3",
    "title": "About",
    "section": "The Song of Roland 1.1-3",
    "text": "The Song of Roland 1.1-3\nCarles li reis, nostre emperere magnes set anz tuz pleins ad estet en Espaigne: Tresqu’en la mer cunquist la tere altaigne."
  },
  {
    "objectID": "articles/article_02.html",
    "href": "articles/article_02.html",
    "title": "Determining Evenness via Recursion",
    "section": "",
    "text": "This problem is ALSO taken from Eloquent Javascript. If curious, it lives here, and it is usually welcoming to visitors. Here’s what it says:"
  },
  {
    "objectID": "articles/article_02.html#the-problem",
    "href": "articles/article_02.html#the-problem",
    "title": "Determining Evenness via Recursion",
    "section": "The Problem",
    "text": "The Problem\n“We’ve seen that % (the remainder operator) can be used to test whether a number is even or odd by using % 2 to see whether it’s divisible by two. Here’s another way to define whether a positive whole number is even or odd:\n-Zero is even.\n-One is odd.\n-For any other number N, its evenness is the same as N - 2.\nDefine a recursive function isEven corresponding to this description. The function should accept a single parameter (a positive, whole number) and return a Boolean.\nTest it on 50 and 75. See how it behaves on -1. Why? Can you think of a way to fix this?”\nWhat Haverbeke is asking the strapping young reader to do here is to create a function that, using recursion, determines whether a number is even or not. It must return either TRUE or FALSE, and it must determine evenness by using the N - 2 technique: if a whole number, when subtracted by 2 enough times, eventually equals 0, it is even, or eventually equals 1, it is odd."
  },
  {
    "objectID": "articles/article_01.html",
    "href": "articles/article_01.html",
    "title": "Looping a Triangle in Javascript",
    "section": "",
    "text": "This problem is taken from Eloquent Javascript. You can find it here. Let’s see what it says:"
  },
  {
    "objectID": "articles/article_01.html#the-problem",
    "href": "articles/article_01.html#the-problem",
    "title": "Looping a Triangle in Javascript",
    "section": "The Problem",
    "text": "The Problem"
  },
  {
    "objectID": "articles/article_02.html#the-solution",
    "href": "articles/article_02.html#the-solution",
    "title": "Determining Evenness via Recursion",
    "section": "The Solution",
    "text": "The Solution\nFirst, we define the function isEven:\nconst isEven = function(x) {\n    if (x &lt; 0) {\n        return console.log(\"!!!!x must be a positive number!!!!\");\n    }\n    if (x == 1) {\n        return console.log(false);\n    } else if (x == 0) {\n        return console.log(true);\n    } else return isEven(x - 2);\n}\nisEven is a function accepting a single positive number, x, that returns either “true” if the number is even, or “false” if the number is odd. But let’s break it down:\nWe first set up a “negative gate”, as I’ll call it:\n\nif (x &lt; 0) {\n    return console.log(\"!!!!x must be a positive number!!!!\");\n}\nThe function first tests whether the number x is a negative number. If so, it prints an angry error message to the console.\nNext, we need to define a “base cases”, or in other words, the criteria needed for the funtion to return a desired outcome. For this function, we need to define two base cases, one for if x = 1 (that is, it’s odd), and another for x = 0 (it is even).\n\nif (x == 1) {\n       return console.log(false);\n   } else if (x == 0) {\n       return console.log(true);\nIf x ends up being equal to 1, the function prints “false” to the console, and if x is equal to 0, “true” is printed to the console.\nNow we get to the fun part: recursion! The"
  },
  {
    "objectID": "articles/article_02.html#the-solution-to-part-1",
    "href": "articles/article_02.html#the-solution-to-part-1",
    "title": "Determining Evenness via Recursion",
    "section": "The Solution to Part 1",
    "text": "The Solution to Part 1\nFirst, we define the function isEven:\nconst isEven = function(x) {\n    if (x &lt; 0) {\n        return console.log(\"!!!!x must be a positive number!!!!\");\n    }\n    if (x == 1) {\n        return console.log(false);\n    } else if (x == 0) {\n        return console.log(true);\n    } else return isEven(x - 2);\n}\nisEven is a function accepting a single positive number, x, that returns either “true” if the number is even, or “false” if the number is odd. But let’s break it down:\nWe first set up a “negative gate”, as I’ll call it:\n\nif (x &lt; 0) {\n    return console.log(\"!!!!x must be a positive number!!!!\");\n}\nThe function first tests whether the number x is a negative number. If so, it prints an angry error message to the console.\nNext, we need to define a “base cases”, or in other words, the criteria needed for the funtion to return a desired outcome. For this function, we need to define two base cases, one for if x = 1 (that is, it’s odd), and another for x = 0 (it is even).\n\nif (x == 1) {\n       return console.log(false);\n   } else if (x == 0) {\n       return console.log(true);\nIf x ends up being equal to 1, the function prints “false” to the console, and if x is equal to 0, “true” is printed to the console.\nNow we get to the fun part: recursion! The main function of the isEven function is to use N (or x) - 2 to find out whether, if 2 is subtracted enough times, N - 2 eventually equals 1 or 0. That looks like this:\n\nif (x == 1) {\n        return console.log(false);\n    } else if (x == 0) {\n        return console.log(true);\n    } else return isEven(x - 2);\n}\nIf x manages to make it by both base cases, the function will rerun isEven using x -2. So, for example, if we make x = 2, it would first pass by both base cases, then rerun isEven where x = 0, instead. Since x = 0 is one of the base cases, the console would then print “true”."
  },
  {
    "objectID": "articles/article_02.html#the-solution-to-part-2",
    "href": "articles/article_02.html#the-solution-to-part-2",
    "title": "Determining Evenness via Recursion",
    "section": "The Solution to Part 2",
    "text": "The Solution to Part 2\nHowever, we aren’t done yet. The problem also asks us to figure out why inputting a negative value for x does not work. The reason for this is because negative numbers are less than both 0 and 1, so the N - 2 method will not work. We could either add an angry error message if x is a negative number, or we can adjust isEven to account for negative numbers. This is negisEven. Say hello!\n\nconst negisEven = function(x) {\n    if (x &lt; 0) {\n        let neg_x = -x;\n        if (neg_x == 1) {\n            return console.log(false);\n        } else if (neg_x == 0) {\n            return console.log(true);\n        }\n            else return negisEven(neg_x - 2)\n    }\n    if (x == 1) {\n        return console.log(false);\n    } else if (x == 0) {\n        return console.log(true);\n    } else return negisEven(x - 2);\n}\nThis function is identical to isEven except in how it handles negative numbers. For our “negative gate”, rather than simply telling you to buzz off, the following takes place:\n\nif (x &lt; 0) {\n        let neg_x = -x;\n        if (neg_x == 1) {\n            return console.log(false);\n        } else if (neg_x == 0) {\n            return console.log(true);\n        }\n            else return negisEven(neg_x - 2)\n    }\nneg_x is equal to the inverse of x, i.e., -x. The function then uses the same testing as isEven: if neg_x is equal to 0, “true” is printed to the console, and if neg_x is equal to 1, then “false” is printed to the console. And if neg_x is equal to neither of those, negisEven is run again, where x is set equal to neg_x. Functionality is identical to isEven after that."
  },
  {
    "objectID": "articles/article_02.html#the-javascript-file",
    "href": "articles/article_02.html#the-javascript-file",
    "title": "Determining Evenness via Recursion",
    "section": "The Javascript File",
    "text": "The Javascript File\nIn order to see this file in action, follow this link to see examples of this function’s use."
  }
]